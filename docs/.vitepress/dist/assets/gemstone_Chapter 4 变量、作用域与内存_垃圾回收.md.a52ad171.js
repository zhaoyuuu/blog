import{_ as s,c as n,o as a,d as l}from"./app.89833151.js";const h=JSON.parse('{"title":"垃圾回收","description":"","frontmatter":{},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":2,"title":"两种标记策略","slug":"两种标记策略","link":"#两种标记策略","children":[{"level":3,"title":"1.标记清理","slug":"_1-标记清理","link":"#_1-标记清理","children":[]},{"level":3,"title":"2.引用计数","slug":"_2-引用计数","link":"#_2-引用计数","children":[]}]},{"level":2,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[]}],"relativePath":"gemstone/Chapter 4 变量、作用域与内存/垃圾回收.md","lastUpdated":1677122049000}'),o={name:"gemstone/Chapter 4 变量、作用域与内存/垃圾回收.md"},e=l(`<h1 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a></h1><p>难度：⭐️⭐️</p><blockquote><p>💌 JS 是使用垃圾回收的语言，通过<strong>自动</strong>内存管理实现内存分配和闲置资源回收。</p></blockquote><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-hidden="true">#</a></h2><ul><li>基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存</li><li>这个过程是<strong>周期性</strong>的</li><li>垃圾回收过程是一个<strong>近似且不完美</strong>的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的</li></ul><h2 id="两种标记策略" tabindex="-1">两种标记策略 <a class="header-anchor" href="#两种标记策略" aria-hidden="true">#</a></h2><blockquote><p>垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，<strong>在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。</strong></p></blockquote><h3 id="_1-标记清理" tabindex="-1">1.标记清理 <a class="header-anchor" href="#_1-标记清理" aria-hidden="true">#</a></h3><blockquote><p>标记清理（mark-and-sweep）是<strong>最常用</strong>的垃圾回收策略。<br></p></blockquote><p>垃圾回收程序执行:</p><ol><li>标记内存中存储的<strong>所有变量</strong>（标记过程的实现并不重要，关键是策略）</li><li>将<strong>所有在上下文中的变量，以及被在上下文中的变量引用的变量</strong>的标记去掉</li><li>在此之后，带有标记的变量就是待删除的了，原因是<strong>任何在上下文中的变量都访问不到它们了</strong>。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</li></ol><h3 id="_2-引用计数" tabindex="-1">2.引用计数 <a class="header-anchor" href="#_2-引用计数" aria-hidden="true">#</a></h3><blockquote><p>另一种没那么常用的垃圾回收策略是引用计数（reference counting）。<br></p></blockquote><p>引用计数在代码中存在循环引用时会出现问题，出现频率低，在此不做详细说明。</p><h2 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-hidden="true">#</a></h2><blockquote><p>分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少。为了避免运行大量 <code>JavaScript</code> 的网页耗尽系统内存而导致操作系统崩溃，我们需要对内存管理有一定了解。</p></blockquote><p>优化内存占用的<strong>最佳手段</strong>：保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 <code>null</code>，从而释放其引用。这也可以叫作<strong>解除引用</strong>。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createPerson</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">localPerson</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">localPerson</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">localPerson</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> globalPerson </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createPerson</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Nicholas</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 解除 globalPerson 对值的引用</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">globalPerson </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"></span></code></pre></div><p>上面的最后一行代码就是这么做的。</p><blockquote><p>不过要注意，解除对一个值的引用<strong>并不会自动导致相关内存被回收</strong>。解除引用的关键在于：确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。</p></blockquote><p><strong>其他有助于内存管理的方法：</strong></p><ul><li>通过 <code>const</code> 和 <code>let</code> 声明提升性能。因为 const 和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。</li><li><strong>内存泄露</strong><ul><li><code>意外声明全局变量</code>是最常见但也最容易修复的内存泄漏问题:</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setName</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Jake</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div>解释器会把变量 name 当作 window 的属性来创建（相当于 <code>window.name = &#39;Jake&#39;</code>）。可想而知，在 window 对象上创建的属性，只要 window 本身不被清理就不会消失。 <ul><li>使用 <code>JavaScript 闭包</code>很容易在不知不觉间造成内存泄漏</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> outer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Jake</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div>以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。</li></ul>`,22),p=[e];function t(c,r,i,y,F,D){return a(),n("div",null,p)}const C=s(o,[["render",t]]);export{h as __pageData,C as default};
