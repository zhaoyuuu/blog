import{_ as s,c as n,o as a,d as l}from"./app.cebf1889.js";const A=JSON.parse('{"title":"关于执行上下文与作用域链","description":"","frontmatter":{},"headers":[{"level":2,"title":"上下文的分类","slug":"上下文的分类","link":"#上下文的分类","children":[{"level":3,"title":"全局上下文：最外层的上下文","slug":"全局上下文-最外层的上下文","link":"#全局上下文-最外层的上下文","children":[]},{"level":3,"title":"函数上下文","slug":"函数上下文","link":"#函数上下文","children":[]}]},{"level":2,"title":"作用域链","slug":"作用域链","link":"#作用域链","children":[]},{"level":2,"title":"变量声明","slug":"变量声明","link":"#变量声明","children":[{"level":3,"title":"1.使用 var 的函数作用域声明","slug":"_1-使用-var-的函数作用域声明","link":"#_1-使用-var-的函数作用域声明","children":[]},{"level":3,"title":"2.使用 let 的块级作用域声明","slug":"_2-使用-let-的块级作用域声明","link":"#_2-使用-let-的块级作用域声明","children":[]},{"level":3,"title":"3. 使用 const 的常量声明","slug":"_3-使用-const-的常量声明","link":"#_3-使用-const-的常量声明","children":[]}]}],"relativePath":"gemstone/Chapter 4 变量、作用域与内存/执行上下文与作用域链.md","lastUpdated":1677122049000}'),o={name:"gemstone/Chapter 4 变量、作用域与内存/执行上下文与作用域链.md"},p=l(`<h1 id="关于执行上下文与作用域链" tabindex="-1">关于执行上下文与作用域链 <a class="header-anchor" href="#关于执行上下文与作用域链" aria-hidden="true">#</a></h1><p>难度：⭐️⭐️</p><blockquote><p>💌 这一部分知识点是面试高频哦</p></blockquote><h2 id="上下文的分类" tabindex="-1">上下文的分类 <a class="header-anchor" href="#上下文的分类" aria-hidden="true">#</a></h2><h3 id="全局上下文-最外层的上下文" tabindex="-1">全局上下文：最外层的上下文 <a class="header-anchor" href="#全局上下文-最外层的上下文" aria-hidden="true">#</a></h3><p><strong>在浏览器中，全局上下文就是我们常说的 <code>window</code> 对象</strong>，因此所有通过 <code>var</code> 定义的全局变量和函数都会成为 <code>window</code> 对象的属性和方法。<br><strong>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数</strong>（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p><h3 id="函数上下文" tabindex="-1">函数上下文 <a class="header-anchor" href="#函数上下文" aria-hidden="true">#</a></h3><p><strong>当代码执行流进入函数时</strong>，函数的上下文被推到一个上下文栈上。<br><strong>在函数执行完之后</strong>，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。<br><code>ECMAScript</code>程序的执行流就是通过这个<strong>上下文栈</strong>进行控制的。</p><h2 id="作用域链" tabindex="-1">作用域链 <a class="header-anchor" href="#作用域链" aria-hidden="true">#</a></h2><p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链（<code>scope chain</code>）。这个作用域链决定 了各级上下文中的代码在访问变量和函数时的顺序。<br><strong>上下文之间的连接是线性的、有序的。</strong> 每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。</p><h2 id="变量声明" tabindex="-1">变量声明 <a class="header-anchor" href="#变量声明" aria-hidden="true">#</a></h2><h3 id="_1-使用-var-的函数作用域声明" tabindex="-1">1.使用 var 的函数作用域声明 <a class="header-anchor" href="#_1-使用-var-的函数作用域声明" aria-hidden="true">#</a></h3><ul><li>使用 <code>var</code> 声明变量时，变量会被自动添加到<strong>最接近的上下文</strong></li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">num1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">num2</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">sum</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">num1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">num2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">sum</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">20</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 30</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(sum)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 报错：sum 在这里不是有效变量</span></span>
<span class="line"></span></code></pre></div><ul><li>但是如果变量<strong>未经声明就被初始化</strong>了，那么它就会自动被添加到全局上下文</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">num1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">num2</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">sum</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">num1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">num2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">sum</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">20</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 30</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(sum)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 30</span></span>
<span class="line"></span></code></pre></div><p>附上红宝书中关于“变量提升”的说明：</p><blockquote><p><code>var</code> 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（<code>hoisting</code>）。</p></blockquote><p>一段可用来考察<strong>作用域链</strong>和<strong>变量提升</strong>的代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(name)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// undefined</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Jake</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// undefined</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Jake</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="_2-使用-let-的块级作用域声明" tabindex="-1">2.使用 let 的块级作用域声明 <a class="header-anchor" href="#_2-使用-let-的块级作用域声明" aria-hidden="true">#</a></h3><blockquote><p><code>let</code> 和 <code>var</code> 有两个区别:<br> 1. <code>let</code> 遵循块级作用域 <br>2. <code>let</code> 在同一作用域内不能声明两次</p></blockquote><ul><li>何谓“块级”作用域：</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 这不是对象字面量，而是一个独立的块</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// JavaScript 解释器会根据其中内容识别出它来</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(d)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// ReferenceError: d 没有定义</span></span>
<span class="line"></span></code></pre></div><ul><li>let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">i) </span><span style="color:#89DDFF;">{...}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(i)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 10</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> j </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> j </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">j) </span><span style="color:#89DDFF;">{...}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(j)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// ReferenceError: j 没有定义</span></span>
<span class="line"></span></code></pre></div><h3 id="_3-使用-const-的常量声明" tabindex="-1">3. 使用 const 的常量声明 <a class="header-anchor" href="#_3-使用-const-的常量声明" aria-hidden="true">#</a></h3><blockquote><p><code>const</code> 和 <code>let</code> 只有一个区别：使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p></blockquote><p>使用<code>const</code>声明 Object 类型时，const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，<strong>但对象的键则不受限制</strong>。</p><p>如果想让整个对象都不能修改，可以使用 <code>Object.freeze()</code>，这样再给属性赋值时虽然不会报错， 但会静默失败：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> o3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">freeze</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">o3</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Jake</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(o3</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// undefined</span></span>
<span class="line"></span></code></pre></div>`,31),e=[p];function t(c,r,y,D,i,F){return a(),n("div",null,e)}const d=s(o,[["render",t]]);export{A as __pageData,d as default};
